// This file will be generated by dfx generate backend
// For now, we'll create type definitions based on main.mo

import type { Principal } from '@dfinity/principal';

export type UserProfile = {
  name: string;
  email?: string;
  farmName?: string;
};

export type Location = {
  latitude: number;
  longitude: number;
};

export type Field = {
  id: bigint;
  owner: Principal;
  name: string;
  location: Location;
  notes: string;
  weatherData?: string;
  soilData?: string;
};

export type CropPrediction = {
  id: bigint;
  fieldId: bigint;
  crop: string;
  suitabilityScore: bigint;
  recommendations: string;
  timestamp: bigint;
};

export type ExternalBlob = {
  id: bigint;
  url: string;
  contentType: string;
  size: bigint;
};

export type DiseaseScan = {
  id: bigint;
  fieldId: bigint;
  plantType: string;
  image: ExternalBlob;
  disease?: string;
  severity?: string;
  timestamp: bigint;
};

export type ChatMessage = {
  id: bigint;
  userId: Principal;
  message: string;
  timestamp: bigint;
};

export type UserPreferences = {
  preferredLanguage: string;
  measurementUnits: string;
};

export interface _SERVICE {
  getCallerUserProfile: () => Promise<UserProfile | null>;
  saveCallerUserProfile: (profile: UserProfile) => Promise<void>;
  addField: (name: string, location: Location, notes: string) => Promise<bigint>;
  getFieldsByUser: (userId: Principal) => Promise<Field[]>;
  updateFieldWeather: (fieldId: bigint, weatherData: string) => Promise<void>;
  makePrediction: (fieldId: bigint, crop: string) => Promise<CropPrediction>;
  getPredictionsByField: (fieldId: bigint) => Promise<CropPrediction[]>;
  uploadScan: (fieldId: bigint, plantType: string, image: ExternalBlob) => Promise<DiseaseScan>;
  getDiseasesByUser: (userId: Principal) => Promise<DiseaseScan[]>;
  sendMessage: (message: string) => Promise<ChatMessage>;
  getChatHistory: (userId: Principal) => Promise<ChatMessage[]>;
  getUserPreferences: (userId: Principal) => Promise<UserPreferences | null>;
  setUserPreferences: (preferences: UserPreferences) => Promise<void>;
}

export const idlFactory = ({ IDL }: any) => {
  const UserProfile = IDL.Record({
    name: IDL.Text,
    email: IDL.Opt(IDL.Text),
    farmName: IDL.Opt(IDL.Text),
  });
  
  const Location = IDL.Record({
    latitude: IDL.Float64,
    longitude: IDL.Float64,
  });
  
  const Field = IDL.Record({
    id: IDL.Nat,
    owner: IDL.Principal,
    name: IDL.Text,
    location: Location,
    notes: IDL.Text,
    weatherData: IDL.Opt(IDL.Text),
    soilData: IDL.Opt(IDL.Text),
  });
  
  const ExternalBlob = IDL.Record({
    id: IDL.Nat,
    url: IDL.Text,
    contentType: IDL.Text,
    size: IDL.Nat,
  });
  
  const DiseaseScan = IDL.Record({
    id: IDL.Nat,
    fieldId: IDL.Nat,
    plantType: IDL.Text,
    image: ExternalBlob,
    disease: IDL.Opt(IDL.Text),
    severity: IDL.Opt(IDL.Text),
    timestamp: IDL.Int,
  });
  
  const CropPrediction = IDL.Record({
    id: IDL.Nat,
    fieldId: IDL.Nat,
    crop: IDL.Text,
    suitabilityScore: IDL.Nat,
    recommendations: IDL.Text,
    timestamp: IDL.Int,
  });
  
  const ChatMessage = IDL.Record({
    id: IDL.Nat,
    userId: IDL.Principal,
    message: IDL.Text,
    timestamp: IDL.Int,
  });
  
  const UserPreferences = IDL.Record({
    preferredLanguage: IDL.Text,
    measurementUnits: IDL.Text,
  });

  return IDL.Service({
    getCallerUserProfile: IDL.Func([], [IDL.Opt(UserProfile)], ['query']),
    saveCallerUserProfile: IDL.Func([UserProfile], [], []),
    addField: IDL.Func([IDL.Text, Location, IDL.Text], [IDL.Nat], []),
    getFieldsByUser: IDL.Func([IDL.Principal], [IDL.Vec(Field)], ['query']),
    updateFieldWeather: IDL.Func([IDL.Nat, IDL.Text], [], []),
    makePrediction: IDL.Func([IDL.Nat, IDL.Text], [CropPrediction], []),
    getPredictionsByField: IDL.Func([IDL.Nat], [IDL.Vec(CropPrediction)], ['query']),
    uploadScan: IDL.Func([IDL.Nat, IDL.Text, ExternalBlob], [DiseaseScan], []),
    getDiseasesByUser: IDL.Func([IDL.Principal], [IDL.Vec(DiseaseScan)], ['query']),
    sendMessage: IDL.Func([IDL.Text], [ChatMessage], []),
    getChatHistory: IDL.Func([IDL.Principal], [IDL.Vec(ChatMessage)], ['query']),
    getUserPreferences: IDL.Func([IDL.Principal], [IDL.Opt(UserPreferences)], ['query']),
    setUserPreferences: IDL.Func([UserPreferences], [], []),
  });
};

export const canisterId = 'uxrrr-q7777-77774-qaaaq-cai';

export const createActor = (canisterId: string, options?: { agent?: any }) => {
  const agent = options?.agent || new (require('@dfinity/agent').HttpAgent)({ host: 'http://127.0.0.1:8080' });
  return require('@dfinity/agent').Actor.createActor(idlFactory, { agent, canisterId });
};

// Runtime helper for ExternalBlob used by the frontend components.
// Provides a small implementation that converts bytes to a base64 data URL
// and exposes helper methods expected by the UI (withUploadProgress, getDirectURL).
export const ExternalBlob = {
  fromBytes: (bytes: Uint8Array) => {
    function bytesToBase64(b: Uint8Array) {
      let binary = '';
      const len = b.length;
      for (let i = 0; i < len; i++) binary += String.fromCharCode(b[i]);
      if (typeof btoa === 'function') return btoa(binary);
      // Fallback for Node (used during SSR/builds)
      return Buffer.from(b).toString('base64');
    }

    const b64 = bytesToBase64(bytes as Uint8Array);
    const obj: any = {
      id: BigInt(Date.now()),
      url: `data:image/jpeg;base64,${b64}`,
      contentType: 'image/jpeg',
      size: BigInt(bytes.length),
      withUploadProgress: (fn: (n: number) => void) => {
        try { fn(100); } catch (e) { /* ignore */ }
        return obj;
      },
      getDirectURL: () => obj.url,
    };

    return obj as unknown as ExternalBlob;
  },
};
